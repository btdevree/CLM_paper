function [fraction_vector, info_improvement_data] = calculate_IIC(params, dataset, number_pseudoreplicates, discrepency_method, optimize_flag)
%CALCULATE_IIC Calculate the information improvement curve for a STORM
% image generated with the given parameters

% Inputs: 
%   params: parameters structure for image generation
%   dataset: n by 2 matrix of event centers used to create the images 
%   number_pseudoreplicates: number of times to regenerate each fractional
%       data split and recalculate the information improvement. Optional, 
%       default = 1.
%   discrepency_method: string, method to use for the discrepency 
%       measurement. See function calculate_discrepency for options.
%       Default = 'sum_of_squares'.
%   optimize_flag: boolean, when set to true the scaling of the partial 
%       image is optimized to minimize the discrepency. Default = true.
% Output:
%   fraction_vector: column vector of the fractions of data used.
%   info_improvement_data: matrix of information improvement fractions,
%       arranged as seperate columns for each pseudoreplicate.

% Set defaults
if nargin < 3; number_pseudoreplicates = 1; end;
if nargin < 4; discrepency_method = 'sum_of_squares'; end;
if nargin < 5; optimize_flat = true; end;

% Fraction of events to use, must include full and zero fractions
fraction_vector = [0; .002; .005; .01; .02; .03; .04; .06; .08; .1; .15; .2; .25; .3; .35; .4; .5; .6; .7; .8; .9; 1];

% Get a copy of the STORMvars structure and channel 2 data created with the given parameter structures
testparams = params; % param_array from loading in 'FD_data_SNxx'
testparams.number_events_ch1 = 10;
testparams.number_background_events_ch1 = 10;
[ ~, data_ch2, STORMvars] = create_test_data_dv(testparams, 10);

% Get the full image and maximum discrepency value
full_image = create_test_STORM_images_dv(params, dataset, data_ch2, STORMvars, false, true, true);
max_discrepency = calculate_discrepency(zeros(size(full_image)), full_image, discrepency_method, optimize_flag);

% Initialize results vector
info_improvement_data = zeros(length(fraction_vector), number_pseudoreplicates); % First point always zero 
info_improvement_data(end, :) = 1; % Last point always one

% Loop through each fraction and calculate the info improvement
for fraction_index = 2:length(fraction_vector)-1 % Don't need to do the first and last fraction
    fraction = fraction_vector(fraction_index);
    
    % Loop through each pseudoreplicate
    for pseudorep_i
    % Generate a logical index array for splitting the data
    number_datapoints = size(dataset, 1);
    number_datapoints_taken = round(number_datapoints * fraction);
    bool_selection = false(size(dataset));
    index_integers = randsample(number_datapoints, number_datapoints_taken);                
    bool_selection(index_integers) = true;
    bool_selection(index_integers + number_datapoints) = true; % select all the y points for corrosponding x in linear representation

    % Split the dataset into larger and smaller datasets
    partial_dataset = reshape(dataset(bool_selection), [number_datapoints_taken, 2]);

    % Create images for the larger and smaller datasets
    [partial_image] = create_test_STORM_images_dv(params, partial_dataset, data_ch2, STORMvars, false, true, true);

    % Get the discrepency and information improvement 
    discrepenecy = calculate_discrepency(partial_image, full_image, discrepency_method, optimize_flag);
    info_improvement_data(fraction_index, pseudorep_index) = 1 - (discrepency / max_discrepency);
    end     
    
    
end

